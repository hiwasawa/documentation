<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.7"/>
<title>Point Cloud Library (PCL): pcl::LCCPSegmentation&lt; PointT &gt; Class Template Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/javascript">
  $(document).ready(function() {
    if ($('.searchresults').length > 0) { searchBox.DOMSearchField().focus(); }
  });
</script>
<link rel="search" href="search-opensearch.php?v=opensearch.xml" type="application/opensearchdescription+xml" title="Point Cloud Library (PCL)"/>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td style="padding-left: 0.5em;">
   <div id="projectname">Point Cloud Library (PCL)
   &#160;<span id="projectnumber">1.8.0</span>
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.7 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Main&#160;Page</span></a></li>
      <li><a href="modules.html"><span>Modules</span></a></li>
      <li><a href="namespaces.html"><span>Namespaces</span></a></li>
      <li class="current"><a href="annotated.html"><span>Classes</span></a></li>
      <li>
        <div id="MSearchBox" class="MSearchBoxInactive">
          <div class="left">
            <form id="FSearchBox" action="search.php" method="get">
              <img id="MSearchSelect" src="search/mag.png" alt=""/>
              <input type="text" id="MSearchField" name="query" value="Search" size="20" accesskey="S" 
                     onfocus="searchBox.OnSearchFieldFocus(true)" 
                     onblur="searchBox.OnSearchFieldFocus(false)"/>
            </form>
          </div><div class="right"></div>
        </div>
      </li>
    </ul>
  </div>
  <div id="navrow2" class="tabs2">
    <ul class="tablist">
      <li><a href="annotated.html"><span>Class&#160;List</span></a></li>
      <li><a href="classes.html"><span>Class&#160;Index</span></a></li>
      <li><a href="inherits.html"><span>Class&#160;Hierarchy</span></a></li>
      <li><a href="functions.html"><span>Class&#160;Members</span></a></li>
    </ul>
  </div>
<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><a class="el" href="namespacepcl.html">pcl</a></li><li class="navelem"><a class="el" href="classpcl_1_1_l_c_c_p_segmentation.html">LCCPSegmentation</a></li>  </ul>
</div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="classpcl_1_1_l_c_c_p_segmentation-members.html">List of all members</a> &#124;
<a href="#nested-classes">Classes</a> &#124;
<a href="#pub-types">Public Types</a> &#124;
<a href="#pub-methods">Public Member Functions</a>  </div>
  <div class="headertitle">
<div class="title">pcl::LCCPSegmentation&lt; PointT &gt; Class Template Reference<div class="ingroups"><a class="el" href="group__segmentation.html">Module segmentation</a></div></div>  </div>
</div><!--header-->
<div class="contents">

<p>A simple segmentation algorithm partitioning a supervoxel graph into groups of locally convex connected supervoxels separated by concave borders.  
 <a href="classpcl_1_1_l_c_c_p_segmentation.html#details">More...</a></p>

<p><code>#include &lt;<a class="el" href="lccp__segmentation_8h_source.html">pcl/segmentation/lccp_segmentation.h</a>&gt;</code></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-types"></a>
Public Types</h2></td></tr>
<tr class="memitem:a1c2eb66ea772fab4b9cc938bfb124e3b"><td class="memItemLeft" align="right" valign="top">typedef boost::adjacency_list<br class="typebreak" />
&lt; boost::setS, boost::setS, <br class="typebreak" />
boost::undirectedS, uint32_t, <br class="typebreak" />
EdgeProperties &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpcl_1_1_l_c_c_p_segmentation.html#a1c2eb66ea772fab4b9cc938bfb124e3b">SupervoxelAdjacencyList</a></td></tr>
<tr class="separator:a1c2eb66ea772fab4b9cc938bfb124e3b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7c1ae820fe571a812141ed1becd76782"><td class="memItemLeft" align="right" valign="top">typedef boost::graph_traits<br class="typebreak" />
&lt; <a class="el" href="classpcl_1_1_l_c_c_p_segmentation.html#a1c2eb66ea772fab4b9cc938bfb124e3b">SupervoxelAdjacencyList</a> &gt;<br class="typebreak" />
::vertex_iterator&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpcl_1_1_l_c_c_p_segmentation.html#a7c1ae820fe571a812141ed1becd76782">VertexIterator</a></td></tr>
<tr class="separator:a7c1ae820fe571a812141ed1becd76782"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a04491d410e22c02b7d929fce0124cc69"><td class="memItemLeft" align="right" valign="top">typedef boost::graph_traits<br class="typebreak" />
&lt; <a class="el" href="classpcl_1_1_l_c_c_p_segmentation.html#a1c2eb66ea772fab4b9cc938bfb124e3b">SupervoxelAdjacencyList</a> &gt;<br class="typebreak" />
::adjacency_iterator&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpcl_1_1_l_c_c_p_segmentation.html#a04491d410e22c02b7d929fce0124cc69">AdjacencyIterator</a></td></tr>
<tr class="separator:a04491d410e22c02b7d929fce0124cc69"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac1008d34ae53627ce8bd51bd04ff7571"><td class="memItemLeft" align="right" valign="top">typedef boost::graph_traits<br class="typebreak" />
&lt; <a class="el" href="classpcl_1_1_l_c_c_p_segmentation.html#a1c2eb66ea772fab4b9cc938bfb124e3b">SupervoxelAdjacencyList</a> &gt;<br class="typebreak" />
::vertex_descriptor&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpcl_1_1_l_c_c_p_segmentation.html#ac1008d34ae53627ce8bd51bd04ff7571">VertexID</a></td></tr>
<tr class="separator:ac1008d34ae53627ce8bd51bd04ff7571"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae3f738a80bfffac4f89c43c48e7df213"><td class="memItemLeft" align="right" valign="top">typedef boost::graph_traits<br class="typebreak" />
&lt; <a class="el" href="classpcl_1_1_l_c_c_p_segmentation.html#a1c2eb66ea772fab4b9cc938bfb124e3b">SupervoxelAdjacencyList</a> &gt;<br class="typebreak" />
::edge_iterator&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpcl_1_1_l_c_c_p_segmentation.html#ae3f738a80bfffac4f89c43c48e7df213">EdgeIterator</a></td></tr>
<tr class="separator:ae3f738a80bfffac4f89c43c48e7df213"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aad0a5b82dfe5cf59481ba0e8bcae5323"><td class="memItemLeft" align="right" valign="top">typedef boost::graph_traits<br class="typebreak" />
&lt; <a class="el" href="classpcl_1_1_l_c_c_p_segmentation.html#a1c2eb66ea772fab4b9cc938bfb124e3b">SupervoxelAdjacencyList</a> &gt;<br class="typebreak" />
::out_edge_iterator&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpcl_1_1_l_c_c_p_segmentation.html#aad0a5b82dfe5cf59481ba0e8bcae5323">OutEdgeIterator</a></td></tr>
<tr class="separator:aad0a5b82dfe5cf59481ba0e8bcae5323"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac5b56b02f769a92c815ff98ee63b497e"><td class="memItemLeft" align="right" valign="top">typedef boost::graph_traits<br class="typebreak" />
&lt; <a class="el" href="classpcl_1_1_l_c_c_p_segmentation.html#a1c2eb66ea772fab4b9cc938bfb124e3b">SupervoxelAdjacencyList</a> &gt;<br class="typebreak" />
::edge_descriptor&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpcl_1_1_l_c_c_p_segmentation.html#ac5b56b02f769a92c815ff98ee63b497e">EdgeID</a></td></tr>
<tr class="separator:ac5b56b02f769a92c815ff98ee63b497e"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:a4a207f7776e9e9b11e47d5b29ca0c5ec"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpcl_1_1_l_c_c_p_segmentation.html#a4a207f7776e9e9b11e47d5b29ca0c5ec">LCCPSegmentation</a> ()</td></tr>
<tr class="separator:a4a207f7776e9e9b11e47d5b29ca0c5ec"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0590d2f40d8786a8d2f807a51bbefc28"><td class="memItemLeft" align="right" valign="top">virtual&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpcl_1_1_l_c_c_p_segmentation.html#a0590d2f40d8786a8d2f807a51bbefc28">~LCCPSegmentation</a> ()</td></tr>
<tr class="separator:a0590d2f40d8786a8d2f807a51bbefc28"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af5a6ac69bde329584570506c7c78b9af"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpcl_1_1_l_c_c_p_segmentation.html#af5a6ac69bde329584570506c7c78b9af">reset</a> ()</td></tr>
<tr class="memdesc:af5a6ac69bde329584570506c7c78b9af"><td class="mdescLeft">&#160;</td><td class="mdescRight">Reset internal memory.  <a href="#af5a6ac69bde329584570506c7c78b9af">More...</a><br /></td></tr>
<tr class="separator:af5a6ac69bde329584570506c7c78b9af"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ace86e741c9ad905ccd0ad5ccba0dea57"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpcl_1_1_l_c_c_p_segmentation.html#ace86e741c9ad905ccd0ad5ccba0dea57">segment</a> (std::map&lt; uint32_t, typename <a class="el" href="classpcl_1_1_supervoxel.html">pcl::Supervoxel</a>&lt; <a class="el" href="structpcl_1_1_point_x_y_z_r_g_b.html">PointT</a> &gt;::Ptr &gt; &amp;supervoxel_clusters_arg, std::multimap&lt; uint32_t, uint32_t &gt; &amp;label_adjacency_arg)</td></tr>
<tr class="memdesc:ace86e741c9ad905ccd0ad5ccba0dea57"><td class="mdescLeft">&#160;</td><td class="mdescRight">Merge supervoxels using local convexity.  <a href="#ace86e741c9ad905ccd0ad5ccba0dea57">More...</a><br /></td></tr>
<tr class="separator:ace86e741c9ad905ccd0ad5ccba0dea57"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a73b148531688cdb949bb9185e6ada8e9"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpcl_1_1_l_c_c_p_segmentation.html#a73b148531688cdb949bb9185e6ada8e9">relabelCloud</a> (<a class="el" href="classpcl_1_1_point_cloud.html">pcl::PointCloud</a>&lt; <a class="el" href="structpcl_1_1_point_x_y_z_l.html">pcl::PointXYZL</a> &gt; &amp;labeled_cloud_arg)</td></tr>
<tr class="memdesc:a73b148531688cdb949bb9185e6ada8e9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Relabels cloud with supervoxel labels with the computed segment labels.  <a href="#a73b148531688cdb949bb9185e6ada8e9">More...</a><br /></td></tr>
<tr class="separator:a73b148531688cdb949bb9185e6ada8e9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a04057539edded520aef675d19c9cd8f5"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpcl_1_1_l_c_c_p_segmentation.html#a04057539edded520aef675d19c9cd8f5">removeSmallSegments</a> (uint32_t min_segment_size_arg)</td></tr>
<tr class="memdesc:a04057539edded520aef675d19c9cd8f5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Segments smaller than segment_size are assigned to label of largest neighbor.  <a href="#a04057539edded520aef675d19c9cd8f5">More...</a><br /></td></tr>
<tr class="separator:a04057539edded520aef675d19c9cd8f5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a81b790f65df1cad331c4c9d375308969"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpcl_1_1_l_c_c_p_segmentation.html#a81b790f65df1cad331c4c9d375308969">getSegmentSupervoxelMap</a> (std::map&lt; uint32_t, std::vector&lt; uint32_t &gt; &gt; &amp;segment_supervoxel_map_arg) const </td></tr>
<tr class="memdesc:a81b790f65df1cad331c4c9d375308969"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get map&lt;SegmentID, std::vector&lt;SuperVoxel IDs&gt; &gt;  <a href="#a81b790f65df1cad331c4c9d375308969">More...</a><br /></td></tr>
<tr class="separator:a81b790f65df1cad331c4c9d375308969"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af5753af2e6779ce28ddc3ae6c137893d"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpcl_1_1_l_c_c_p_segmentation.html#af5753af2e6779ce28ddc3ae6c137893d">getSegmentAdjacencyMap</a> (std::map&lt; uint32_t, std::set&lt; uint32_t &gt; &gt; &amp;segment_adjacency_map_arg)</td></tr>
<tr class="memdesc:af5753af2e6779ce28ddc3ae6c137893d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get map &lt;SegmentID, std::set&lt;Neighboring SegmentIDs&gt; &gt;  <a href="#af5753af2e6779ce28ddc3ae6c137893d">More...</a><br /></td></tr>
<tr class="separator:af5753af2e6779ce28ddc3ae6c137893d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3f191a48e932512ca812dba4fb1bcb56"><td class="memItemLeft" align="right" valign="top">float&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpcl_1_1_l_c_c_p_segmentation.html#a3f191a48e932512ca812dba4fb1bcb56">getConcavityToleranceThreshold</a> () const </td></tr>
<tr class="memdesc:a3f191a48e932512ca812dba4fb1bcb56"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get normal threshold.  <a href="#a3f191a48e932512ca812dba4fb1bcb56">More...</a><br /></td></tr>
<tr class="separator:a3f191a48e932512ca812dba4fb1bcb56"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a02e0ababedc75dd8442b9033e86552c1"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpcl_1_1_l_c_c_p_segmentation.html#a02e0ababedc75dd8442b9033e86552c1">getSVAdjacencyList</a> (<a class="el" href="classpcl_1_1_l_c_c_p_segmentation.html#a1c2eb66ea772fab4b9cc938bfb124e3b">SupervoxelAdjacencyList</a> &amp;adjacency_list_arg) const </td></tr>
<tr class="memdesc:a02e0ababedc75dd8442b9033e86552c1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the supervoxel adjacency graph with classified edges (boost::adjacency_list).  <a href="#a02e0ababedc75dd8442b9033e86552c1">More...</a><br /></td></tr>
<tr class="separator:a02e0ababedc75dd8442b9033e86552c1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abc2b7be596c2785fb8664922bbca7177"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpcl_1_1_l_c_c_p_segmentation.html#abc2b7be596c2785fb8664922bbca7177">setConcavityToleranceThreshold</a> (float concavity_tolerance_threshold_arg)</td></tr>
<tr class="memdesc:abc2b7be596c2785fb8664922bbca7177"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set normal threshold.  <a href="#abc2b7be596c2785fb8664922bbca7177">More...</a><br /></td></tr>
<tr class="separator:abc2b7be596c2785fb8664922bbca7177"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a391f12ac00e266066391bbff3fd1d823"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpcl_1_1_l_c_c_p_segmentation.html#a391f12ac00e266066391bbff3fd1d823">setSmoothnessCheck</a> (bool use_smoothness_check_arg, float voxel_res_arg, float seed_res_arg, float smoothness_threshold_arg=0.1)</td></tr>
<tr class="memdesc:a391f12ac00e266066391bbff3fd1d823"><td class="mdescLeft">&#160;</td><td class="mdescRight">Determines if a smoothness check is done during segmentation, trying to invalidate edges of non-smooth connected edges (steps).  <a href="#a391f12ac00e266066391bbff3fd1d823">More...</a><br /></td></tr>
<tr class="separator:a391f12ac00e266066391bbff3fd1d823"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad33984ab71f1df520adee88782c7b62e"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpcl_1_1_l_c_c_p_segmentation.html#ad33984ab71f1df520adee88782c7b62e">setSanityCheck</a> (bool use_sanity_criterion_arg)</td></tr>
<tr class="memdesc:ad33984ab71f1df520adee88782c7b62e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Determines if we want to use the sanity criterion to invalidate singular connected patches.  <a href="#ad33984ab71f1df520adee88782c7b62e">More...</a><br /></td></tr>
<tr class="separator:ad33984ab71f1df520adee88782c7b62e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9eb7bbe2a9c3a47ddbd6069fc6d1af41"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpcl_1_1_l_c_c_p_segmentation.html#a9eb7bbe2a9c3a47ddbd6069fc6d1af41">setKFactor</a> (unsigned int k)</td></tr>
<tr class="memdesc:a9eb7bbe2a9c3a47ddbd6069fc6d1af41"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set the value used for k convexity.  <a href="#a9eb7bbe2a9c3a47ddbd6069fc6d1af41">More...</a><br /></td></tr>
<tr class="separator:a9eb7bbe2a9c3a47ddbd6069fc6d1af41"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><h3>template&lt;typename PointT&gt;<br />
class pcl::LCCPSegmentation&lt; PointT &gt;</h3>

<p>A simple segmentation algorithm partitioning a supervoxel graph into groups of locally convex connected supervoxels separated by concave borders. </p>
<dl class="section note"><dt>Note</dt><dd>If you use this in a scientific work please cite the following paper: S. C. Stein, M. Schoeler, J. Papon, F. Woergoetter <a class="el" href="class_object.html">Object</a> Partitioning using Local Convexity In Proceedings of the IEEE Conference on Computer Vision and Pattern Recognition (CVPR) 2014 </dd></dl>
<dl class="section author"><dt>Author</dt><dd>Simon Christoph Stein and Markus Schoeler (<a href="#" onclick="location.href='mai'+'lto:'+'msc'+'ho'+'ele'+'r@'+'gwd'+'g.'+'de'; return false;">mscho<span style="display: none;">.nosp@m.</span>eler<span style="display: none;">.nosp@m.</span>@gwdg<span style="display: none;">.nosp@m.</span>.de</a>) </dd></dl>

<p>Definition at line <a class="el" href="lccp__segmentation_8h_source.html#l00059">59</a> of file <a class="el" href="lccp__segmentation_8h_source.html">lccp_segmentation.h</a>.</p>
</div><h2 class="groupheader">Member Typedef Documentation</h2>
<a class="anchor" id="a04491d410e22c02b7d929fce0124cc69"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename PointT &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">typedef boost::graph_traits&lt;<a class="el" href="classpcl_1_1_l_c_c_p_segmentation.html#a1c2eb66ea772fab4b9cc938bfb124e3b">SupervoxelAdjacencyList</a>&gt;::adjacency_iterator <a class="el" href="classpcl_1_1_l_c_c_p_segmentation.html">pcl::LCCPSegmentation</a>&lt; <a class="el" href="structpcl_1_1_point_x_y_z_r_g_b.html">PointT</a> &gt;::<a class="el" href="classpcl_1_1_l_c_c_p_segmentation.html#a04491d410e22c02b7d929fce0124cc69">AdjacencyIterator</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Definition at line <a class="el" href="lccp__segmentation_8h_source.html#l00076">76</a> of file <a class="el" href="lccp__segmentation_8h_source.html">lccp_segmentation.h</a>.</p>

</div>
</div>
<a class="anchor" id="ac5b56b02f769a92c815ff98ee63b497e"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename PointT &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">typedef boost::graph_traits&lt;<a class="el" href="classpcl_1_1_l_c_c_p_segmentation.html#a1c2eb66ea772fab4b9cc938bfb124e3b">SupervoxelAdjacencyList</a>&gt;::edge_descriptor <a class="el" href="classpcl_1_1_l_c_c_p_segmentation.html">pcl::LCCPSegmentation</a>&lt; <a class="el" href="structpcl_1_1_point_x_y_z_r_g_b.html">PointT</a> &gt;::<a class="el" href="classpcl_1_1_l_c_c_p_segmentation.html#ac5b56b02f769a92c815ff98ee63b497e">EdgeID</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Definition at line <a class="el" href="lccp__segmentation_8h_source.html#l00081">81</a> of file <a class="el" href="lccp__segmentation_8h_source.html">lccp_segmentation.h</a>.</p>

</div>
</div>
<a class="anchor" id="ae3f738a80bfffac4f89c43c48e7df213"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename PointT &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">typedef boost::graph_traits&lt;<a class="el" href="classpcl_1_1_l_c_c_p_segmentation.html#a1c2eb66ea772fab4b9cc938bfb124e3b">SupervoxelAdjacencyList</a>&gt;::edge_iterator <a class="el" href="classpcl_1_1_l_c_c_p_segmentation.html">pcl::LCCPSegmentation</a>&lt; <a class="el" href="structpcl_1_1_point_x_y_z_r_g_b.html">PointT</a> &gt;::<a class="el" href="classpcl_1_1_l_c_c_p_segmentation.html#ae3f738a80bfffac4f89c43c48e7df213">EdgeIterator</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Definition at line <a class="el" href="lccp__segmentation_8h_source.html#l00079">79</a> of file <a class="el" href="lccp__segmentation_8h_source.html">lccp_segmentation.h</a>.</p>

</div>
</div>
<a class="anchor" id="aad0a5b82dfe5cf59481ba0e8bcae5323"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename PointT &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">typedef boost::graph_traits&lt;<a class="el" href="classpcl_1_1_l_c_c_p_segmentation.html#a1c2eb66ea772fab4b9cc938bfb124e3b">SupervoxelAdjacencyList</a>&gt;::out_edge_iterator <a class="el" href="classpcl_1_1_l_c_c_p_segmentation.html">pcl::LCCPSegmentation</a>&lt; <a class="el" href="structpcl_1_1_point_x_y_z_r_g_b.html">PointT</a> &gt;::<a class="el" href="classpcl_1_1_l_c_c_p_segmentation.html#aad0a5b82dfe5cf59481ba0e8bcae5323">OutEdgeIterator</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Definition at line <a class="el" href="lccp__segmentation_8h_source.html#l00080">80</a> of file <a class="el" href="lccp__segmentation_8h_source.html">lccp_segmentation.h</a>.</p>

</div>
</div>
<a class="anchor" id="a1c2eb66ea772fab4b9cc938bfb124e3b"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename PointT &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">typedef boost::adjacency_list&lt;boost::setS, boost::setS, boost::undirectedS, uint32_t, EdgeProperties&gt; <a class="el" href="classpcl_1_1_l_c_c_p_segmentation.html">pcl::LCCPSegmentation</a>&lt; <a class="el" href="structpcl_1_1_point_x_y_z_r_g_b.html">PointT</a> &gt;::<a class="el" href="classpcl_1_1_l_c_c_p_segmentation.html#a1c2eb66ea772fab4b9cc938bfb124e3b">SupervoxelAdjacencyList</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Definition at line <a class="el" href="lccp__segmentation_8h_source.html#l00074">74</a> of file <a class="el" href="lccp__segmentation_8h_source.html">lccp_segmentation.h</a>.</p>

</div>
</div>
<a class="anchor" id="ac1008d34ae53627ce8bd51bd04ff7571"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename PointT &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">typedef boost::graph_traits&lt;<a class="el" href="classpcl_1_1_l_c_c_p_segmentation.html#a1c2eb66ea772fab4b9cc938bfb124e3b">SupervoxelAdjacencyList</a>&gt;::vertex_descriptor <a class="el" href="classpcl_1_1_l_c_c_p_segmentation.html">pcl::LCCPSegmentation</a>&lt; <a class="el" href="structpcl_1_1_point_x_y_z_r_g_b.html">PointT</a> &gt;::<a class="el" href="classpcl_1_1_l_c_c_p_segmentation.html#ac1008d34ae53627ce8bd51bd04ff7571">VertexID</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Definition at line <a class="el" href="lccp__segmentation_8h_source.html#l00078">78</a> of file <a class="el" href="lccp__segmentation_8h_source.html">lccp_segmentation.h</a>.</p>

</div>
</div>
<a class="anchor" id="a7c1ae820fe571a812141ed1becd76782"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename PointT &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">typedef boost::graph_traits&lt;<a class="el" href="classpcl_1_1_l_c_c_p_segmentation.html#a1c2eb66ea772fab4b9cc938bfb124e3b">SupervoxelAdjacencyList</a>&gt;::vertex_iterator <a class="el" href="classpcl_1_1_l_c_c_p_segmentation.html">pcl::LCCPSegmentation</a>&lt; <a class="el" href="structpcl_1_1_point_x_y_z_r_g_b.html">PointT</a> &gt;::<a class="el" href="classpcl_1_1_l_c_c_p_segmentation.html#a7c1ae820fe571a812141ed1becd76782">VertexIterator</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Definition at line <a class="el" href="lccp__segmentation_8h_source.html#l00075">75</a> of file <a class="el" href="lccp__segmentation_8h_source.html">lccp_segmentation.h</a>.</p>

</div>
</div>
<h2 class="groupheader">Constructor &amp; Destructor Documentation</h2>
<a class="anchor" id="a4a207f7776e9e9b11e47d5b29ca0c5ec"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename PointT &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classpcl_1_1_l_c_c_p_segmentation.html">pcl::LCCPSegmentation</a>&lt; <a class="el" href="structpcl_1_1_point_x_y_z_r_g_b.html">PointT</a> &gt;::<a class="el" href="classpcl_1_1_l_c_c_p_segmentation.html">LCCPSegmentation</a> </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Definition at line <a class="el" href="lccp__segmentation_8hpp_source.html#l00045">45</a> of file <a class="el" href="lccp__segmentation_8hpp_source.html">lccp_segmentation.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a0590d2f40d8786a8d2f807a51bbefc28"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename PointT &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classpcl_1_1_l_c_c_p_segmentation.html">pcl::LCCPSegmentation</a>&lt; <a class="el" href="structpcl_1_1_point_x_y_z_r_g_b.html">PointT</a> &gt;::~<a class="el" href="classpcl_1_1_l_c_c_p_segmentation.html">LCCPSegmentation</a> </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Definition at line <a class="el" href="lccp__segmentation_8hpp_source.html#l00058">58</a> of file <a class="el" href="lccp__segmentation_8hpp_source.html">lccp_segmentation.hpp</a>.</p>

</div>
</div>
<h2 class="groupheader">Member Function Documentation</h2>
<a class="anchor" id="a3f191a48e932512ca812dba4fb1bcb56"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename PointT &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">float <a class="el" href="classpcl_1_1_l_c_c_p_segmentation.html">pcl::LCCPSegmentation</a>&lt; <a class="el" href="structpcl_1_1_point_x_y_z_r_g_b.html">PointT</a> &gt;::getConcavityToleranceThreshold </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get normal threshold. </p>
<dl class="section return"><dt>Returns</dt><dd>The concavity tolerance angle in [deg] that is currently set </dd></dl>

<p>Definition at line <a class="el" href="lccp__segmentation_8h_source.html#l00146">146</a> of file <a class="el" href="lccp__segmentation_8h_source.html">lccp_segmentation.h</a>.</p>

</div>
</div>
<a class="anchor" id="af5753af2e6779ce28ddc3ae6c137893d"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename PointT &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classpcl_1_1_l_c_c_p_segmentation.html">pcl::LCCPSegmentation</a>&lt; <a class="el" href="structpcl_1_1_point_x_y_z_r_g_b.html">PointT</a> &gt;::getSegmentAdjacencyMap </td>
          <td>(</td>
          <td class="paramtype">std::map&lt; uint32_t, std::set&lt; uint32_t &gt; &gt; &amp;&#160;</td>
          <td class="paramname"><em>segment_adjacency_map_arg</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get map &lt;SegmentID, std::set&lt;Neighboring SegmentIDs&gt; &gt; </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[out]</td><td class="paramname">segment_adjacency_map_arg</td><td>map &lt; SegmentID, std::set&lt; Neighboring SegmentIDs&gt; &gt;. On error the map is empty. </td></tr>
  </table>
  </dd>
</dl>

<p>Definition at line <a class="el" href="lccp__segmentation_8h_source.html#l00128">128</a> of file <a class="el" href="lccp__segmentation_8h_source.html">lccp_segmentation.h</a>.</p>

</div>
</div>
<a class="anchor" id="a81b790f65df1cad331c4c9d375308969"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename PointT &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classpcl_1_1_l_c_c_p_segmentation.html">pcl::LCCPSegmentation</a>&lt; <a class="el" href="structpcl_1_1_point_x_y_z_r_g_b.html">PointT</a> &gt;::getSegmentSupervoxelMap </td>
          <td>(</td>
          <td class="paramtype">std::map&lt; uint32_t, std::vector&lt; uint32_t &gt; &gt; &amp;&#160;</td>
          <td class="paramname"><em>segment_supervoxel_map_arg</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get map&lt;SegmentID, std::vector&lt;SuperVoxel IDs&gt; &gt; </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[out]</td><td class="paramname">segment_supervoxel_map_arg</td><td>The output container. On error the map is empty. </td></tr>
  </table>
  </dd>
</dl>

<p>Definition at line <a class="el" href="lccp__segmentation_8h_source.html#l00112">112</a> of file <a class="el" href="lccp__segmentation_8h_source.html">lccp_segmentation.h</a>.</p>

</div>
</div>
<a class="anchor" id="a02e0ababedc75dd8442b9033e86552c1"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename PointT &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classpcl_1_1_l_c_c_p_segmentation.html">pcl::LCCPSegmentation</a>&lt; <a class="el" href="structpcl_1_1_point_x_y_z_r_g_b.html">PointT</a> &gt;::getSVAdjacencyList </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classpcl_1_1_l_c_c_p_segmentation.html#a1c2eb66ea772fab4b9cc938bfb124e3b">SupervoxelAdjacencyList</a> &amp;&#160;</td>
          <td class="paramname"><em>adjacency_list_arg</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get the supervoxel adjacency graph with classified edges (boost::adjacency_list). </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[out]</td><td class="paramname">adjacency_list_arg</td><td>The supervoxel adjacency list with classified (convex/concave) edges. On error the list is empty. </td></tr>
  </table>
  </dd>
</dl>

<p>Definition at line <a class="el" href="lccp__segmentation_8h_source.html#l00154">154</a> of file <a class="el" href="lccp__segmentation_8h_source.html">lccp_segmentation.h</a>.</p>

</div>
</div>
<a class="anchor" id="a73b148531688cdb949bb9185e6ada8e9"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename PointT &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classpcl_1_1_l_c_c_p_segmentation.html">pcl::LCCPSegmentation</a>&lt; <a class="el" href="structpcl_1_1_point_x_y_z_r_g_b.html">PointT</a> &gt;::relabelCloud </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classpcl_1_1_point_cloud.html">pcl::PointCloud</a>&lt; <a class="el" href="structpcl_1_1_point_x_y_z_l.html">pcl::PointXYZL</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>labeled_cloud_arg</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Relabels cloud with supervoxel labels with the computed segment labels. </p>
<p>labeled_cloud_arg should be created using the getLabeledCloud method of the <a class="el" href="classpcl_1_1_supervoxel_clustering.html" title="Implements a supervoxel algorithm based on voxel structure, normals, and rgb values. ">SupervoxelClustering</a> class. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in,out]</td><td class="paramname">labeled_cloud_arg</td><td>Cloud to relabel </td></tr>
  </table>
  </dd>
</dl>

<p>Definition at line <a class="el" href="lccp__segmentation_8hpp_source.html#l00075">75</a> of file <a class="el" href="lccp__segmentation_8hpp_source.html">lccp_segmentation.hpp</a>.</p>

<p>References <a class="el" href="common_2include_2pcl_2point__cloud_8h_source.html#l00434">pcl::PointCloud&lt; T &gt;::begin()</a>, and <a class="el" href="common_2include_2pcl_2point__cloud_8h_source.html#l00435">pcl::PointCloud&lt; T &gt;::end()</a>.</p>

</div>
</div>
<a class="anchor" id="a04057539edded520aef675d19c9cd8f5"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename PointT &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classpcl_1_1_l_c_c_p_segmentation.html">pcl::LCCPSegmentation</a>&lt; <a class="el" href="structpcl_1_1_point_x_y_z_r_g_b.html">PointT</a> &gt;::removeSmallSegments </td>
          <td>(</td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>min_segment_size_arg</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Segments smaller than segment_size are assigned to label of largest neighbor. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">min_segment_size_arg</td><td>Segments smaller than this size will be filtered </td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>Currently this runs multiple times, until no segment &lt; min_segment_size is found. Could be faster. </dd></dl>

<p>Definition at line <a class="el" href="lccp__segmentation_8hpp_source.html#l00133">133</a> of file <a class="el" href="lccp__segmentation_8hpp_source.html">lccp_segmentation.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="af5a6ac69bde329584570506c7c78b9af"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename PointT &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classpcl_1_1_l_c_c_p_segmentation.html">pcl::LCCPSegmentation</a>&lt; <a class="el" href="structpcl_1_1_point_x_y_z_r_g_b.html">PointT</a> &gt;::reset </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Reset internal memory. </p>

<p>Definition at line <a class="el" href="lccp__segmentation_8hpp_source.html#l00063">63</a> of file <a class="el" href="lccp__segmentation_8hpp_source.html">lccp_segmentation.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="ace86e741c9ad905ccd0ad5ccba0dea57"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename PointT &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classpcl_1_1_l_c_c_p_segmentation.html">pcl::LCCPSegmentation</a>&lt; <a class="el" href="structpcl_1_1_point_x_y_z_r_g_b.html">PointT</a> &gt;::segment </td>
          <td>(</td>
          <td class="paramtype">std::map&lt; uint32_t, typename <a class="el" href="classpcl_1_1_supervoxel.html">pcl::Supervoxel</a>&lt; <a class="el" href="structpcl_1_1_point_x_y_z_r_g_b.html">PointT</a> &gt;::Ptr &gt; &amp;&#160;</td>
          <td class="paramname"><em>supervoxel_clusters_arg</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::multimap&lt; uint32_t, uint32_t &gt; &amp;&#160;</td>
          <td class="paramname"><em>label_adjacency_arg</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Merge supervoxels using local convexity. </p>
<p>The input parameters are generated by using the <a class="el" href="classpcl_1_1_supervoxel_clustering.html" title="Implements a supervoxel algorithm based on voxel structure, normals, and rgb values. ">SupervoxelClustering</a> class. To retrieve the output use the relabelCloud method. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">supervoxel_clusters_arg</td><td>Map of &lt; supervoxel labels, supervoxels &gt; </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">label_adjacency_arg</td><td>The graph defining the supervoxel adjacency relations </td></tr>
  </table>
  </dd>
</dl>

<p>Definition at line <a class="el" href="lccp__segmentation_8hpp_source.html#l00275">275</a> of file <a class="el" href="lccp__segmentation_8hpp_source.html">lccp_segmentation.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="abc2b7be596c2785fb8664922bbca7177"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename PointT &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classpcl_1_1_l_c_c_p_segmentation.html">pcl::LCCPSegmentation</a>&lt; <a class="el" href="structpcl_1_1_point_x_y_z_r_g_b.html">PointT</a> &gt;::setConcavityToleranceThreshold </td>
          <td>(</td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>concavity_tolerance_threshold_arg</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Set normal threshold. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">concavity_tolerance_threshold_arg</td><td>the concavity tolerance angle in [deg] to set </td></tr>
  </table>
  </dd>
</dl>

<p>Definition at line <a class="el" href="lccp__segmentation_8h_source.html#l00170">170</a> of file <a class="el" href="lccp__segmentation_8h_source.html">lccp_segmentation.h</a>.</p>

</div>
</div>
<a class="anchor" id="a9eb7bbe2a9c3a47ddbd6069fc6d1af41"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename PointT &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classpcl_1_1_l_c_c_p_segmentation.html">pcl::LCCPSegmentation</a>&lt; <a class="el" href="structpcl_1_1_point_x_y_z_r_g_b.html">PointT</a> &gt;::setKFactor </td>
          <td>(</td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>k</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Set the value used for k convexity. </p>
<p>For k&gt;0 convex connections between p_i and p_j require k common neighbors of these patches that have a convex connection to both. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">k</td><td>factor used for extended convexity check </td></tr>
  </table>
  </dd>
</dl>

<p>Definition at line <a class="el" href="lccp__segmentation_8h_source.html#l00203">203</a> of file <a class="el" href="lccp__segmentation_8h_source.html">lccp_segmentation.h</a>.</p>

</div>
</div>
<a class="anchor" id="ad33984ab71f1df520adee88782c7b62e"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename PointT &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classpcl_1_1_l_c_c_p_segmentation.html">pcl::LCCPSegmentation</a>&lt; <a class="el" href="structpcl_1_1_point_x_y_z_r_g_b.html">PointT</a> &gt;::setSanityCheck </td>
          <td>(</td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>use_sanity_criterion_arg</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Determines if we want to use the sanity criterion to invalidate singular connected patches. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">use_sanity_criterion_arg</td><td>Determines if the sanity check is performed </td></tr>
  </table>
  </dd>
</dl>

<p>Definition at line <a class="el" href="lccp__segmentation_8h_source.html#l00195">195</a> of file <a class="el" href="lccp__segmentation_8h_source.html">lccp_segmentation.h</a>.</p>

</div>
</div>
<a class="anchor" id="a391f12ac00e266066391bbff3fd1d823"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename PointT &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classpcl_1_1_l_c_c_p_segmentation.html">pcl::LCCPSegmentation</a>&lt; <a class="el" href="structpcl_1_1_point_x_y_z_r_g_b.html">PointT</a> &gt;::setSmoothnessCheck </td>
          <td>(</td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>use_smoothness_check_arg</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>voxel_res_arg</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>seed_res_arg</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>smoothness_threshold_arg</em> = <code>0.1</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Determines if a smoothness check is done during segmentation, trying to invalidate edges of non-smooth connected edges (steps). </p>
<p>Two supervoxels are unsmooth if their plane-to-plane distance DIST &gt; (expected_distance + smoothness_threshold_*voxel_resolution_). For parallel supervoxels, the expected_distance is zero. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">use_smoothness_check_arg</td><td>Determines if the smoothness check is used </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">voxel_res_arg</td><td>The voxel resolution used for the supervoxels that are segmented </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">seed_res_arg</td><td>The seed resolution used for the supervoxels that are segmented </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">smoothness_threshold_arg</td><td>Threshold (/fudging factor) for smoothness constraint according to the above formula. </td></tr>
  </table>
  </dd>
</dl>

<p>Definition at line <a class="el" href="lccp__segmentation_8h_source.html#l00181">181</a> of file <a class="el" href="lccp__segmentation_8h_source.html">lccp_segmentation.h</a>.</p>

</div>
</div>
<hr/>The documentation for this class was generated from the following files:<ul>
<li>/home/travis/build/PointCloudLibrary/pcl/segmentation/include/pcl/segmentation/<a class="el" href="lccp__segmentation_8h_source.html">lccp_segmentation.h</a></li>
<li>/home/travis/build/PointCloudLibrary/pcl/segmentation/include/pcl/segmentation/impl/<a class="el" href="lccp__segmentation_8hpp_source.html">lccp_segmentation.hpp</a></li>
</ul>
</div><!-- contents -->
<hr>
<div id="footer">
<p>
Except where otherwise noted, the PointClouds.org web pages are licensed under <a href="http://creativecommons.org/licenses/by/3.0/">Creative Commons Attribution 3.0</a>. 
</p>
<p>Pages generated on Fri Jan 30 2015 13:38:14</p>
</div> <!-- #footer -->
</body>
</html>
